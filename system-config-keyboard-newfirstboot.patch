diff -up ./src/keyboard_gui.py.firstboot ./src/keyboard_gui.py
--- ./src/keyboard_gui.py.firstboot	2006-10-04 16:54:13.000000000 -0400
+++ ./src/keyboard_gui.py	2008-01-22 17:44:29.000000000 -0500
@@ -4,8 +4,9 @@
 ## Brent Fox <bfox@redhat.com>
 ## Mike Fulbright <msf@redhat.com>
 ## Jeremy Katz <katzj@redhat.com>
+## Chris Lumens <clumens@redhat.com>
 ##
-## Copyright (C) 2002, 2003 Red Hat, Inc.
+## Copyright (C) 2002, 2003, 2007 Red Hat, Inc.
 ##
 ## This program is free software; you can redistribute it and/or modify
 ## it under the terms of the GNU General Public License as published by
@@ -30,8 +31,10 @@ import os
 
 import rhpl.keyboard as keyboard
 
-sys.path.append('/usr/share/firstboot')
-from firstboot_module_window import FirstbootModuleWindow
+from firstboot.config import *
+from firstboot.constants import *
+from firstboot.functions import *
+from firstboot.module import *
 
 sys.path.append('/usr/share/system-config-keyboard')
 import keyboard_backend
@@ -48,9 +51,11 @@ translate.textdomain ("rhpl")
 ## Icon for windows
 ##
 
-iconPixbuf = None      
+iconFile = "/usr/share/system-config-keyboard/pixmaps/system-config-keyboard.png"
+iconPixbuf = None
+
 try:
-    iconPixbuf = gtk.gdk.pixbuf_new_from_file("/usr/share/system-config-keyboard/pixmaps/system-config-keyboard.png")
+    iconPixbuf = gtk.gdk.pixbuf_new_from_file(iconFile)
 except:
     pass
 
@@ -85,37 +90,56 @@ def scrollToIdleHandler((view, store, id
     if id:
 	gobject.source_remove(id)
 
-class KeyboardWindow(FirstbootModuleWindow):
-    runPriority = 20
-    moduleName = N_("Keyboard")
-    moduleClass = "reconfig"
-    windowTitle = N_("Keyboard")
-    commentTag = N_("Configure the system keyboard")
-    htmlTag = "kybd"
-    shortMessage = N_("Select the appropriate keyboard for the system.")
+class moduleClass(Module):
     instDataKeyboard = None
 
-    def getNext(self):
-        self.kbd.set(self.type)
-        self.kbd.beenset = 1
-        self.kbd.activate()
+    def __init__(self):
+        Module.__init__(self)
+        self.icon = "system-config-keyboard.png"
+        self.mode = MODE_RECONFIG
+        self.priority = 20
+        self.sidebarTitle = N_("Keyboard")
+        self.title = N_("Keyboard")
+
+        self.kbd = None
+
+    def apply(self, interface, testing=False):
+        if testing:
+            return RESULT_SUCCESS
 
-        if self.instDataKeyboard:
-            self.instDataKeyboard.set(self.type)
-            self.instDataKeyboard.beenset = 1
-            self.instDataKeyboard.activate()
+        self.getNext()
+        self.kbd.write()
+        # XXX should we munge the xconfig from this tool?
 
-    def select_row(self, *args):
-        rc = self.modelView.get_selection().get_selected()
-        if rc:
-            model, iter = rc
-            if iter is not None:
-                key = self.modelStore.get_value(iter, 0)
-                if key:
-                    self.type = key
+        # If the /etc/X11/XF86Config file exists, then change it's keyboard settings
+        fullname, layout, model, variant, options = self.kbdDict[self.kbd.get()]
+
+        keyboardBackend.modifyXconfig(fullname, layout, model, variant, options)
+
+        try:
+            #If we're in reconfig mode, this will fail because there is no self.mainWindow
+            self.mainWindow.destroy()
+        except:
+            pass
+
+        return RESULT_SUCCESS
+
+    def createScreen(self, defaultByLang=None, kbd=None):
+        if not kbd:
+            self.kbd = keyboard.Keyboard()
+        else:
+            self.kbd = kbd
 
-    def setupScreen(self, defaultByLang, kbd):
-        self.kbd = kbd
+        self.kbd.read()
+
+        self.vbox = gtk.VBox()
+        self.vbox.set_spacing(10)
+        self.vbox.set_border_width(10)
+
+        label = gtk.Label(_("Select the appropriate keyboard for the system."))
+        label.set_alignment(0.0, 0.5)
+        label.set_size_request(500, -1)
+        self.vbox.pack_start(label, False)
 
         if not self.kbd.beenset:
             default = defaultByLang
@@ -128,7 +152,7 @@ class KeyboardWindow(FirstbootModuleWind
         self.modelStore.set_sort_column_id(1, gtk.SORT_ASCENDING)
 
         # Sort the UI by the descriptive names, not the keymap abbreviations.
-        self.kbdDict = kbd.modelDict
+        self.kbdDict = self.kbd.modelDict
         lst = self.kbdDict.items()
         lst.sort(lambda a, b: cmp(a[1][0], b[1][0]))
 
@@ -165,91 +189,84 @@ class KeyboardWindow(FirstbootModuleWind
         self.modelViewSW.set_shadow_type(gtk.SHADOW_IN)
         self.modelViewSW.add(self.modelView)
 
-        # XXX set up a test area and do some sort of instant apply ?
-
-        # set up the icon
-        p = None
-        try:
-            p = gtk.gdk.pixbuf_new_from_file("../pixmaps/system-config-keyboard.png")
-        except:
-            try:
-                p = gtk.gdk.pixbuf_new_from_file("/usr/share/system-config-keyboard/pixmaps/system-config-keyboard.png")
-            except:
-                pass
-
-        if p:
-            self.icon = gtk.Image()
-            self.icon.set_from_pixbuf(p)
-
-        self.myVbox = gtk.VBox()
-        self.myVbox.pack_start(self.modelViewSW, True)
+        self.vbox.pack_start(self.modelViewSW, True)
 
 	setupTreeViewFixupIdleHandler(self.modelView,
 				      self.modelView.get_model())
-        
-        
-    def apply(self, *args):
-        self.getNext()
-        if not self.doDebug:
-            self.kbd.write()
-        # XXX should we munge the xconfig from this tool?
-
-        # If the /etc/X11/XF86Config file exists, then change it's keyboard settings
-        fullname, layout, model, variant, options = self.kbdDict[self.kbd.get()]
 
-        keyboardBackend.modifyXconfig(fullname, layout, model, variant, options)
+    def initializeUI(self):
+        pass
 
-        try:
-            #If we're in reconfig mode, this will fail because there is no self.mainWindow
-            self.mainWindow.destroy()
-        except:
-            pass
-        return 0
+    def select_row(self, *args):
+        rc = self.modelView.get_selection().get_selected()
+        if rc:
+            model, iter = rc
+            if iter is not None:
+                key = self.modelStore.get_value(iter, 0)
+                if key:
+                    self.type = key
 
-    def launch(self, doDebug=None):
-        self.doDebug = doDebug
-        if doDebug:
-            print "in keyboard launch"
-        kbd = keyboard.Keyboard()
-        kbd.read()
-        # XXX read the language to determine default keyboard?
-        self.setupScreen("en_US", kbd)
+    # This is needed by anaconda, which doesn't need to do everything
+    # that the regular apply method does.
+    def getNext(self):
+        self.kbd.set(self.type)
+        self.kbd.beenset = 1
+        self.kbd.activate()
 
-        label = gtk.Label(_(self.shortMessage))
-        label.set_alignment(0.0, 0.5)
-        label.set_size_request(500, -1)
-        self.myVbox.pack_start(label, False)
-        self.myVbox.reorder_child(label, 0)
-        self.myVbox.set_spacing(10)
-        self.myVbox.set_border_width(10)
+        if self.instDataKeyboard:
+            self.instDataKeyboard.set(self.type)
+            self.instDataKeyboard.beenset = 1
+            self.instDataKeyboard.activate()
 
-        outerVBox = gtk.VBox()
-        outerVBox.pack_start(self.myVbox)
+    def getScreen(self, defaultByLang, kbd):
+        self.createScreen(defaultByLang, kbd)
+        return self.vbox
+
+    # All of these methods are needed for running s-c-keyboard as a
+    # standalone program.
+    def _okClicked(self, *args):
+        return self.apply(None, false)
 
-        return outerVBox, self.icon, self.windowTitle
+    def destroy(self, *args):
+        gtk.main_quit()
 
     def stand_alone(self):
-        self.doDebug = None
-        kbd = keyboard.Keyboard()
-        kbd.read()
-        # XXX read the language to determine default keyboard?
-        self.setupScreen("en_US", kbd)
-        return FirstbootModuleWindow.stand_alone(self, KeyboardWindow.windowTitle, iconPixbuf)
-
-    def anacondaScreen(self, label, kbd, instDataKeyboard=None):
-        print label, kbd.get()
-        self.doDebug = None
-        self.keyboardLabel = label
-        self.instDataKeyboard = instDataKeyboard
-        self.setupScreen(kbd.get(), kbd)
-        return FirstbootModuleWindow.anacondaScreen(self, KeyboardWindow.windowTitle, iconPixbuf, 400, 350)
-
-    def okAnacondaClicked(self, *args):
-        print "okAnacondaClicked", args
-        self.getNext()
-        print self.kbd.get()
-        self.keyboardLabel.set_text(self.kbd.modelDict[self.kbd.get()][0])
-        self.mainWindow.destroy()
+        self.createScreen(defaultByLang="en_US")
 
-childWindow = KeyboardWindow
+        self.mainWindow = gtk.Dialog()
+        self.mainWindow.connect("destroy", self.destroy)
+        self.mainWindow.set_border_width(10)
+        self.mainWindow.set_size_request(400, 350)
+        self.mainWindow.set_position(gtk.WIN_POS_CENTER)
+
+        self.mainWindow.set_icon(iconPixbuf)
+        self.mainWindow.set_title(_(self.title))
+
+        okButton = self.mainWindow.add_button('gtk-ok', 0)
+        okButton.connect("clicked", self._okClicked)
+
+        toplevel = gtk.VBox()
+        toplevel.set_spacing(5)
+        iconBox = gtk.HBox(False, 5)
+        iconBox.pack_start(loadToImage(iconFile))
+
+        msgLabel = gtk.Label(_("Select the appropriate keyboard for the system."))
+        msgLabel.set_line_wrap(True)
+        msgLabel.set_alignment(0.0, 0.5)
+        iconBox.pack_start(msgLabel)
+
+        toplevel.pack_start(iconBox, False)
+        toplevel.pack_start(self.vbox, True)
+
+        # Remove the duplicate label.
+        label = self.vbox.get_children()[0]
+        self.vbox.remove(label)
+
+        # Remove the hsep from the dialog.  It's ugly.
+        hsep = self.mainWindow.get_children()[0].get_children()[0]
+        self.mainWindow.get_children()[0].remove(hsep)
+        self.mainWindow.vbox.pack_start(toplevel)
+        self.mainWindow.show_all()
+        gtk.main()
 
+childWindow = moduleClass
